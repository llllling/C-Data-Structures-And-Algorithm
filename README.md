# 자료구조와 알고리즘 공부 with C++

코딩 테스트를 위한 자료 구조와 알고리즘 with C++ 책을 보며 정리

## 목표

**C++ 공부하면서 요구사항에 맞는 적절한 자료구조과 알고리즘 선택을 위해 학습한다.**

## 내용
```
자료 구조는 다양한 방식의 데이터 저장 방식을 의미하며, 
그 안에 저장된 데이터에 접근하는 데 필요한 비용을 결정함.

그러나 데이터를 저장하고 검색하는 방법 외에도 
계산 문제를 해결하기 위해 데이터를 변환하는 방법도 프로그램의 유용성을 결정하는 중요한 요소이다.
주어진 문제가 있을 때, 데이터에 대한 정확한 정의와 데이터 변환 순서는 일련의 명령에 의해 결정되며, 
이를 알고리즘이라고 한다.
```
- 응용 프로그램에서 데이터를 처리하기에 앞서 먼저 **데이터를 어떻게 저장할 것인가를 결정**해야 한다. => 데이터를 이용하여 **수행할 작업의 종류와 작업 빈도에 따라 달라짐.**
  - 지연 시간, 사용 메모리, 기타 매개변수 측면에서 최선의 성능을 제공하도록 구현 방법 선택

* 어떠한 자료 구조를 선택할 것인가를 결정함에 있어 적합한 지표로, 알고리즘 복잡도 또는 **시간 복잡도**가 있다.
* <span style="background-color: yellow; color: black;">시간 복잡도</span> : 특정 작업을 수행하는 데 걸리는 시간을 **데이터 크기에 대한 수식**으로 표현하는 방식
  - 데이터 크기가 변경되면 연산 시간이 어떻게 변하는 지를 보여줌.
* 자료 구조는 크게 **연속된 자료 구조와 연결된 자료 구조로 구분**할 수 있다.

### 연속된 자료 구조

- 배열

* 모든 원소를 **단일 메모리 청크에 저장**한다.
* 단일 메모리 청크(모든 원소가 저장되어 있는) 안에서 각각의 원소가 모두 같은 타입이므로 같은 크기의 메모리를 사용.

  ```
  BA(Base Address)  = 시작 주소
  sizeof(type) = 원소 하나에 필요한 메모리 크기

  첫번째 원소의 메모리 주소 : BA
  두번째 원소의 메모리 주소 : BA + sizeof(type)
  세번째 원소의 메모리 주소 : BA + 2 * sizeof(type)
  ...
  ```

  - 즉, i번째 원소에 접근하려면 BA + i \* sizeof(type) 수식 사용

* 위와 같은 구조 때문에 배열의 전체 크기에 상관없이 앞의 수식을 통해 모든 원소에 곧바로 접근할 수 있다 => 데이터 접근 시간은 항상 일정함.
* 빅오 표기법 **O(1)** 로 표현
* 데이터 저장을 위해 정확하게 데이터의 크기만큼 메모리를 사용
* 크게 정적 배열, 동적 배열 두가지로 나뉨
  - 두가지 유형 모두 다양한 연산에서 동일한 성능

#### 정적 배열

- 선언된 블록이 끝나면 소멸
- **스택 메모리 영역에 할당**되기 때문에 함수를 벗어날 때 자동으로 해제

```C++
  int arr[size];
```

#### 동적 배열

- 프로그래머가 생성할 시점과 해제할 시점을 자유롭게 결정할 수 있다.
- **힙 영역**에 할당되며 사용자가 직접 해지하기 전까지 유지.

```C++
  int* arr = new int[size];
```

#### 캐시 지역성

- 배열 같은 자료 구조에서 각 원소는 서로 인접해 있기 때문에 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 캐시로 가져옴.
- 다시 주변 원소에 접근할 때에 해당 원소를 캐시에서 가져오게 되며, 이 작업은 매우 빠르게 동작 => 이러한 속성을 **캐시 지역성**

* 어떤 연산의 점근적 시간 복잡도 계산에는 영향을 주지 않지만 실제 동작에서 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 점은 큰 장점이 됨.
* 배열에서 모든 원소를 순차적으로 접근하는 경우, 첫번째 원소를 가져온 후 다음 원소는 캐시에서 바로 참조할 수 있으므로 **배열은 캐시 지역성이 좋다고 말함.**

### 연결된 자료 구조

- 연결 리스트

* 노드(node)라고 하는 **여러 개의 메모리 청크에 데이터를 저장**
  - 서로 다른 메모리 위치에 데이터가 저장됨.
  * 각 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있다.
  * 맨 마지막 노드의 포인터는 NULL을 가짐.
* 특정 원소에 접근하려면 리스트의 시작(헤드) 부분부터 원하는 원소까지 next 포인터를 따라서 이동해야 함. => i번째 원소에 접근하려면 연결 리스트 내부를 i번 이동하는 작업 필요
* 위와 같은 이유 때문에 원소 접근 시간은 노드 개수에 비례하여, 빅오 표기법 **O(n)**
* 각 노드의 포인터 저장을 위해 여분의 메모리를 사용
* 배열과 달리 포인터를 이용하여 **원소의 삽입, 삭제** 빠르게 수행
  - 삽입 : 1, 2 노드가 있고 3번을 추가한다면 1번 노드의 next 포인터를 3번을 가리키도록 수정, 3번 next포인터에 2번 포인터 가리키게 만듬
  - 삭제 : 1, 2, 3 노드가 있고, 2번 삭제한다면 1번 next포인터에 3번 노드를 가리키게 만듬.
    - 2번 노드의 메모리 할당을 해제하거나 다른 적절한 처리 수행
* 원소가 메모리에 **연속적으로 저장되지 않기 때문에 캐시 지역성
  기대할 수 없음.**
  - 즉, 현재 노드가 가리키는 다음 노드에 직접 방문하지 않고 다음 원소를 캐시로 가져올 방법 없음.
  - 따라서, <span style="background-color: gray; color: black;">배열과 연결 리스트에서 모든 원소를 차례대로 방문하는 작업은 이론적으로 같은 시간 복잡도를 가지지만, 실제로는 연결 리스트의 성능이 조금 떨어짐</span>

### 다양한 연산에 대한 배열과 연결 리스트의 시간 복잡도

<table>
<thead>
    <th>파라미터</th>
    <th>배열</th>
    <th>연결 리스트</th>
</thead>
<tbody>
    <tr>
        <td>임의 접근</td>
        <td>O(1)</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td>맨 뒤에 원소 삽입</td>
        <td>O(1)</td>
        <td>O(1)</td>
    </tr>
    <tr>
        <td>중간에 원소 삽입</td>
        <td>O(n)</td>
        <td>O(1)</td>
    </tr>
    <tr>
        <td>캐시 지역성</td>
        <td>있음</td>
        <td>없음</td>
    </tr>
</tbody>
</table>
