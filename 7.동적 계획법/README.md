# 동적 계획법
* 주어진 문제에 동적 계획법을 적용할 수 있는지 분석할 수 있다.
* 메모제이션과 타뷸레이션 기법을 서로 비교하여 적절한 방법을 선택할 수 있다.
* 메모이제이션을 위한 적절한 캐시 사용 방법을 찾을 수 있다.
* 동적 계획법은 분할 정복 패러타임 개념을 확장한 것으로, 특정 분류의 문제에 사용됨.
* **동적 계획법이 자주 사용되는 몇 가지 예**
    * 조합(특정 기준을 만족하는 시퀀스의 조합 또는 순열의 개수 구하기)
    * 문자열과 시퀀스(편집 거리, 최장 공통 부분 시퀀스, 최장 증가 부분 시퀀스 등)
    * 그래프(최단 경로 문제)
    * 머신 러닝(음성/얼굴 인식)
## 동적 계획법이란?
* 피보나치 수열 {0, 1, 1, 2, 3, 5 ,...}을 수식으로 표현
    * 수식을 보면 재귀적인 관계를 가짐을 알 수 있음.
    * **기저 조건** : F(0), F(1) 더이상 재귀가 없어도 해를 구할 수 있는 지점을 나타냄
    ```
    F(0) = 0
    F(1) = 1
    ...
    F(n) = F(n-1) + F(n-2)
    ```
    <div><img src="./a1.jpg" width="300"/></div>

    * 위와 같은 방식을 하향식 해법이라고 부름.
    * c++ 재귀함수로 구현
        ```c++
        int Fibonacci(int n) {
            if (n < 2)
                return n;
            return Fibonacci(n - 1) + Fibonacci(n - 2);
        }
        ```
* **분할 정복과 동적 계획법을 구분하는 특성**
    1.  **중복 되는 부분 문제** 
        * 분할 정복 문제에서는 전체 문제가 독립적인 부분 문제로 나뉘는 경향이 있지만, 동적 계획법의 경우에는 **같은 부분 문제가 반복적**으로 나타난다.  또한, **여러 부분 문제가 서로 완전히 동일**하다.
        * 예를 들어, F(2) 는 F(4)와 F(3)을 구하는 과정에서 중복해서 나타남.
    2. **최적 부분 구조** 
        * 전체 문제에 대한 최적해가 부분 문제의 최적해의 조합으로 표현할 수 있을 때 최적 부분 구조를 갖는다고 표현함.
        * 예를 들어, F(2)의 해를 구해야 할 경우, 이것이 F(4) 또는 F(3) 중에서 어느 것을 구하기 위해 필요한지에 상관없이 같은 방식의 연산을 수행하면 됨. 이를 최적 부분 구조라고 함.
* 동적 계획법에서는 본질적으로 반복 계산을 피하기 위해 이전에 해결한 부분 문제의 해답을 캐시에 저장하는 방식을 사용함.
## 메모이제이션:하향식 접근 방법
```
하향식 방식에서는 부분 문제의 해를 캐시에 넣어 사용하는 기술을 메모이제이션이라고 하며, 이 방법은 모든 동적 계획법 문제에 적용할 수 있다.
```
* 피보나치 구현
    ```c++
    const int UNKNOWN = -1;
    const int MAX_SIZE = 100;
    int Fibonacci(int n) {
        if (n < 2)
            return n;
        if (memo[n] != UNKNOWN) return memo[n];

        int result = Fibonacci(n - 1) + Fibonacci(n - 2);
        memo[n] = result;
        return result;
    }
    ```
* 메모이제이션은 아래 조건들을 만족한다고 가정해야 한다.
    1. 고유한 특성은 유지하면서 서로 다른 상태의 유사성을 활용하는 캐시 사용 방식을 고안할 수 있다.
        * 부분 문제 해법을 캐시에 인덱싱하여 저장하는 방법이 유효하고 유용해야 한다는 의미.
        * 캐시 사용 방법이 유효하려면 같은 의미의 부분 문제 해법을 정확하게 일치시켜 저장해야 함
        * 또한 캐시 사용 방법이 유용하려면 너무 특정 상태에만 치우치게 동작하면 안된다. 
            ```
            예를 들어, 모든 부분 문제가 같은 위치의 캐시를 참조하는 경우 if (memo[n] != UNKNOWN)와 같은 조건에 걸리는 경우가 거의 없을 것이다.
            ```
    2. 사용 가능한 스택 공간을 초과하기 전에 필요한 모든 부분 문제의 해답을 누적할 수 있다.
        * 스택 오버플로우가 발생할 가능성에 관한 것으로, 너무 많은 재귀 함수 호출을 필요로 하는 하향식 접근 방법에서 근본적으로 발생하는 문제.
        * 주어진 문제가 재귀 호출을 너무 많이 필요로 하는 경우, 메모이제이션을 사용하지 못할 수도 있다.

## 타뷸레이션:상향식 접근 방법
* 일반적으로 타뷸레이션을 더 많이 의식하여 사용함.
```
 타뷸레이션은 기저 조건 해답부터 시작하여 모든 부분 문제에 대한 해답을 표에 저장한 후 재사용 하는 방식.
```
* 피보나치 구현
    ```c++
    int Fibonacci(int n) {
        vector<int> DP(n + 1, 0);
        DP[1] = 1;

        for (int i = 2; i <= n; i++) {
            DP[i] = DP[i - 1] + DP[i - 2];
        }
        
        return DP[n];
    }
    ```
* 각각의 부분 문제 상태를 재귀적으로 표현할 수 있어야 하기 때문에 메모이제이션 방법보다 개념적으로 더욱 어렵게 느껴짐.
* 타뷸레이션 방식의 장점
    * 메모리 상용량 관점에서 매우 효율적
    * 가능한 모든 상태를 기록하는 룩업 테이블을 생성할 수 있다. 
    * 그러므로 주어진 문제에 대해 임의의 여러 상태를 참조해야 하는 경우에 타뷸레이션이 최선의 방법
* 메모이제이션으로 해결할 수 있는 모든 문제는 타뷸레이션 방식으로 재구성할 수 있으며, 그 반대도 가능.
