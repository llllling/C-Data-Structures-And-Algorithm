# 그래프 알고리즘
* 그래프에서 틀정 원소를 찾기 위해 적절한 탐색 방법을 선택하여 구현
* 프림 알고리즘을 이용하여 최소 신장 트리를 구할 수 있다.
* 프림 알고리즘과 크루스칼 알고리즘 중에서 주어진 상황에 적합한 알고리즘을 선택할 수 있다.
* 다익스트라 알고리즘을 이용하여 두 정점 사이의 최단 경로를 찾을 수 있다.
## 그래프 순회 문제
* 특정 정점에서 시작하여 나머지 모든 정점을 방문하는 문제를 그래프 순회 문제라고 함.
* 그래프 순회 문제는 그래프에서 특정 정점을 찾기 위한 용도로 사용될 수 있기 때문에 **그래프 탐색 문제**라고도 부름.
### 너비 우선 탐색(BFS, Breadth-First Search)
* bfs.cpp
* 시작 정점을 경계(frontier)에 추가하는 것으로 시작한다.
* 경계는 이전에 방문했던 정점들에 의해 구성됨. 
* 그리고 현재 경계에 인접한 정점을 반본적으로 탐색
* 시간 복잡도는 O(V + E), V는 정점의 개수, E는 에지의 개수를 의미
#### BFS의 동작
1. 먼저 시작점인 '우리집'정점을 방문
    * 아래 이미지에서 빨간색 점선이 현재 경계를 나타냄
    * 인접한 정점 : R1, R2
    <div><img src="./bfs1.jpg" width="400" height="300"/></div>
2. 아래 이미지는 R1, R2를 방문한 후의 BFS 상태. 둘 중 어느것을 먼저 방문해도 상관없다.
    * 시작 정점과 같은 거리에 있는 정점들의 방문 순서는 임의로 지정해도 됨.
    <div><img src="./bfs2.jpg" width="400" height="300"/></div>
3. 아래 이미지는 R3, R5, R4, R6를 방문한 후의 BFS 상태이며, 전체 그래프를 순회하기 직전의 모습
     <div><img src="./bfs3.jpg" width="400" height="300"/></div>
* BFS는 모든 정점에 대해 자식 정점을 손자 정점보다 먼저 방문한다는 점이 중요한 특징.
* BFS를 구현할 경우, 보통 경계를 별도의 자료 구조로 만들어서 명시적으로 사용하지는 않는다. 대신 <span style="background-color:yellow;color:black;">정점ID를 **큐**에 저장하여 시작 정점과 가까운 정점을 멀리 잇는 정점보다 먼저 방문할 수 있도록 구현</span>

### 깊이 우선 탐색(DFS, Depth-First Search)
* dfs.cpp
* 시작 정점에서 시작하여 특정 경로를 따라 가능한 멀리 있는 정점을 재귀적으로 먼저 방문하는 방식
* 그리고 더 방문할 정점이 없어지면 다른 경로를 찾아 다시 멀어지는 방향으로 탐색을 반복한다.
* 이러한 그래프 탐색 방법을 **백트래킹**이라고 함.
* 시간 복잡도는 O(V + E), V는 정점의 개수, E는 에지의 개수를 의미
#### DFS의 동작
1. 가장 먼저 '우리집'정점부터 방문
    <div><img src="./dfs1.jpg" width="400" height="300"/></div>
2. 다음으로 R2 정점을 방문한다. 여기서는 우리집 정점과 연결된 정점 R1과 R2 중에서 R2를 임의로 선택.
    * R1과 R2 중에서 어느 것을 먼저 방문해도 DFS알고리즘으로 모든 정점을 탐색할 수 있다.
    <div><img src="./dfs2.jpg" width="400" height="300"/></div>
3. 이번에는 R3 정점을 방문한다. R2와 연결된 정점은 R1과 R3이며, 이 중 임의로 R3를 먼저 선택한다.
    <div><img src="./dfs3.jpg" width="400" height="300"/></div>
4. 아래 이미지는 인접한 정점 중에서 아직 방문하지 않은 정점을 찾아 탐색을 계속 진행하는 과정이다. 마지막으로 R1을 방문하면 이제 방문하지 않은 정점을 찾을 수 없게 됨. 이런 경우 탐색 종료
    <div><img src="./dfs4.jpg" width="400" height="300"/></div>
* DFS를 구현하는 방식은 <span style="background-color:yellow; color:black;">**스택**을 사용한다.</span>후입선출 속성으로 현재 정점과 인접한 정점들을 재귀적으로 이동하면 방문할 때 사용하기에 적합한 자료구조
### BFS와 DFS의 차이점과 적합한 사용 시나리오
* BFS는 시작 정점에서 가장 가까운 정점을 찾는데 적합. DFS는 대체로 시작 정점에서 멀리 있는 정점을 찾을 때 적합
* BFS는 특정 정점을 방문할 경우, 시작 정점에서 해당 정점까지의 최단 거리 경로가 보장. 그러나 DFs에서는 최단 경로를 보장하지 않음. 이러한 속성 때문에 **단일-시작 또는 다중-시작 최단 경로 알고리즘이 BFS 알고리즘을 조금 변경하여 사용**하고 있다.
* BFS는 현재 경계에서 인접한 모든 정점을 방문하므로 BFS에 의해 생성된 검색 트리는 짧고 넓은 편이며 많은 메모리를 필요로 함. DFS에 생성된 검색 트리는 길고 좁은 편이며, 상대적으로 적은 메모리를 필요로 함.
### 이분 그래프(bipartite graph)  판별하기
* bipartite_check.cpp
```
정점을 두 개의 집합으로 나눌 수 있는 그래프이며, 이때 그래프의 모든 에지는 서로 다른 집합에 속한 정점끼리 연결되어야 함.
```
* 예를 들어, 학생 목록과 수업 목록이 있을 때, 학생들이 어떤 수업을 수강하고 있는 지를 이분 그래프로 표현
    * 아래와 같은 모델이 주어질 경우, 특정 학생이 신청한 두 개의 수업이 같은  시간대에 중복되지 않도록 수강 계획을 만드는 데 사용할 수 있음. 
    * 예를 들어, 유미가 수학과 영어 과목을 수강했다면, 두 수업은 같은 시간대에 진행되면 안됨.
    * 수업 시간표 작성 시 이러한 충돌을 최소화 하는 작업은 그래프에서 최대 유량 문제(maximum flow problem)를 풀어 달성할 수 있다.
        * 최대 유량 문제에 대해서 몇 가지 표준 알고리즘 : 포드-폴커슨 알고리즘, 디닉 알고리즘, 푸시-리레이블 알고리즘
    <div><img src="./bipartite.jpg" width="400" height="300"/></div>
* 넷플릭스나 유튜브 같은 대형 비디오 스트리밍 플랫폼에서 제공되는 영화 목록과 시청자 사이의 관계도 이분 그래프를 사용하여 모델링 할 수 있음.
* 이분 그래프에 대해 흥미로운 사실은 최대 매칭(maximum matching) 또는 최소 정점 커버(minimum vertex cover) 문제처럼 일반 그래프에서는 NP-완전인 문제들이 이분 그래프에서는 다항 시간으로 풀 수 있다는 점, 따라서 **주어진 그래프가 이분 그래프인지 아닌지를 알아내는 것은 매우 중요함**
#### 이분 그래프를 반펼하는 알고리즘은 DFS를 조금 변형하여 만들 수 있다.
1. 1번 정범부터 DFS를 시작한다고 가정. 그러므로 1번 정점을 스택에 추가
2. 만약 스택에 방문하지 않은 정점이 남아 있으면 스택에서 정점을 하나 꺼내고 이를 현재 정점으로 설정
3. 이전 정점에 할당된 색상이 '검은색'이면, 현재 정점에 '빨간색'을 할당한다. 반대로 이전 정점에 할당된 색상이 '빨간색'이면, 현재 정점에 '검은색'을 할당.
4. 현재 정점과 인접한 정점들 중에서 아직 방문하지 않은 정점들을 스택에 넣고, 현재 정점을 방문한 것으로 설정.
5. 모든 정점에 색상이 지정될 때까지 2~4단계를 반복한다. 알고리즘 종료 시 모든 정점에 색상이 칠해져 있다면 이 그래프는 이분 그래프이다.
6. 만약 탐색을 진행하다가 만나게 된 정점이 이미 방문한 정점이고, 이 정점의 색상이 현재 할당할 색상과 다른 색상이면(즉, 이전에 칠한 색상과 같은 색상이면) 알고리즘을 종료하고, 해당 그래프가 이분 그래프가 아니라고 판별.