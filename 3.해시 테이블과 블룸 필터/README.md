# 해시 테이블과 블룸 필터
* 대용량 데이터를 다루는 응용 프로그램에서 발생할 수 있는 룩업 관련 문제에 대해 이해할 수 있다.
* <span style="background-color: yellow; color: black;">룩업(lookup, 조회)</span> : 특정 원소가 컨테이너에 있는지 확인하거나 또는 컨테이너에서 특정 키에 해당하는 값을 찾는 작업을 의미
*  모든 원소를 선형으로 검토하여 원하는 값을 찾는 작업은 일반적으로 매우 많은 시간이 소요됨. => 저장된 데이터가 많아질수록 검색 시간은 크게 증가함.
## 해시 테이블
* 해싱 : 각각의 데이터를 가급적 고유한 숫자 값으로 표현하고, 나중에 같은 숫자 값을 사용하여 데이터의 유무를 확인하거나 또는 해당 숫자에 대응하는 원본 데이터를 추출하는 작업
* 해시 함수  : 주어진 데이터로부터 고유한 숫자 값을 계산하는 함수
### 체이닝 
* 다수의 키가 같은 해시 값을 갖는 경우 충돌 문제 발생
* 체이닝이란 => 해시 테이블의 특정 위치에서 하나의 키를 저장하는 것이 아니라 하나의 연결 리스트를 저장한다.
    * 벡터 대신 연결리스트를 사용하는 이유 : 특정 위치의 원소를 빠르게 삭제하기 위함

```c++
class hash_map
{
	std::vector<std::list<int>> data;

	public:
		hash_map(size_t n)
		{
			data.resize(n);
		}

		void insert(uint value)
		{
			int n = data.size();
			data[value % n].push_back(value);
			std::cout << value << "을(를) 삽입했습니다." << std::endl;
		}

		bool find(uint value)
		{
			int n = data.size();
			auto& entries = data[value % n];
			return std::find(entries.begin(), entries.end(), value) != entries.end();
		}

		void erase(uint value)
		{
			int n = data.size();
			auto& entries = data[value % n];
			auto iter = std::find(entries.begin(), entries.end(), value);

			if (iter != entries.end())
			{
				entries.erase(iter);
				std::cout << value << "을(를) 삭제했습니다." << std::endl;
			}
		}
	};
}
```
* 삽입 함수의 시간 복잡도 O(1)
* 룩업과 삭제는 데이터 크기와 해시 테이블 크기에 따라 상당히 느릴 수 있다. 
    * 예를 들어 모든 키가 같은 해시 값을 가질 경우, 룩업 연산은 연결 리스트에서 선형 검색을 수행한느 것과 같으므로 O(N)의 시간 복잡도를 가짐.</span>
* <span style="background-color: yellow; color: black;">만약 해시 테이블이 저장할 키 개수에 비해 매우 작다면 충돌이 많이 발생, 리스트는 평균적으로 더 길어짐.
* <span style="background-color: yellow; color: black;">반면에, 너무 큰 해시 테이블을 가지고 있다면 실제 데이터는 듬성듬성 존재하게 되므로 메모리 낭비가 발생</span>
* 응용프로그램 동작 시나리오를 고려하여 해시 테이블 크기를 적절히 조절해야 한다. => 이를 위한 수식을 하나 정의할 수 있다.
#### 부하율 
* 해시 테이블에서 각각의 리스트에 저장되는 키의 평균 개수를 나타냄.
```
         전체 키 개수
부하율 = -------------
        해시 테이블 크기
```
* 만약 키 개수가 해시 테이블 크기와 같다면 부하율은 1 => 매우 이상적인 상태로, 모든 연산이이 O(1)에 가깝게 작동하고 모든 메모리 공간을 적절하게 활용함.
* 부하율이 1보다 작으면 리스트당 키가 하나도 저장되지 않은 경우가 있다는 것이고, 메모리 낭비될 수 있음.
* 부하율이 1보다 크면 리스트의 평균 길이가 1보다 크다는 의미. 검색, 삭제 등의 함수가 약간 느리게 동작할 수 있다.
* 부하율은 항상 O(1) 시간 복잡도로 계산할 수 있음.
### 열린 주소 지정
* 충돌을 해결하는 다른 방법으로 열린 주소 지정이 있다. 이 방법은 체이닝처럼 해시 테이블에 추가적인 리스트를 붙여서 데이터를 저장하는 방식이 아니라 모든 원소를 해시 테이블 내부에 저장하는 방식이다.
* 해시 테이블의 크기가 반드시 데이터 개수보다 커야함.
* 특정 해시 값 위치가 이미 사용되고 있다면 테이블의 다른 비어 있는 위치를 탐색하는 것.
* 다른 비어 있는 위치를 찾는 방법에는 여러 가지가 있다.
#### 선형 탐색
```
충돌이 발생하면 해당 위치에서 하나씩 다음 셀 위치로 이동하면서 셀이 비어 있는지를 확인하고, 비어 있는 셀을 찾으면 원소를 삽입함.
```
* 데이터가 특정 위치에 군집화되는 경우 문제 발생 => 특정 해시 값이 너무 자주 발생해서 데이터가 몇 개의 그룹으로 뭉치는 형태로 저장되는 것이 군집화 된다는 것!
    * 예를 들어 크기가 100인 해시 테이블이 있는데, 대부분의 키가 3에서 7 사이의 해시 값으로 변환된다고 생각. 이 경우 대부분의 데이터가 3~7 이후 위치에 차례대로 저장될 것이고, 이로 인해 검색 속도는 급격하게 느려질 것임.
#### 이차함수 탐색
```
군집화를 해결하기 위해 선형 방정식이 아닌 이차 방정식을 사용하여 탐색을 수행할 수 있다. 이를 이차함수 탐색이라고 함.
```
* 데이터 x를 hash(x) 위치에 삽입하려고 할 경우 이 위치가 이미 사용 중이라면 hash(x+ 1^2^)으로 이동하고, 그다음은 hash(x + 2^2^)로 이동.
    * 이처럼 이동 폭을 이차함수 형태로 증가시키면 데이터 군집이 나타날 확률은 상대적으로 줄어든다.
* 선형 탐색 및 이차함수 탐색은 모두 원소 위치가 기존 삽입되어 있는 다른 원소들에 의해 영향을 받는다. 기존에 저장되어 있던 원소는 새로 삽입하는 원소와 서로 다른 해시값을 가질 수 있다. 이 경우에도 충돌이 발생 할 수 있음
    * 예를 들어 선형 탐색에서 해시 값이 4인 키가 2개 있는 경우, 하나는 4, 다른 하나는 5 위치에 삽입한다. 이후 해시 값이 5인 키를 새로 삽입하려고 한다면 이를 6위치에 해야함. => 이 키는 다른 원소와 중복된 해시 값을 가지지 않았지만 저장되는 위치에는 영향을 받았음.
### 뻐꾸기 해싱
```
크기가 같은 두 개의 해시 테이블을 사용하고, 각각의 해시 테이블은 서로 다른 해시 함수를 가짐.
```
* 완벽한 해싱 기법 중 하나.
* 위의 방법들은 최악의 상황에서는 O(1)의 시간 복잡도를 보장하지 않지만 뻐꾸기 해싱은 구현만 제대로 한다면 O(1)을 만족함.
* 모든 원소는 두 해시 테이블 중 하나에 있을 수 있으며, 그 위치는 해당 해시 테이블의 해시 함수에 의해 결정됨.
* 이전에 설명한 해싱 기법과 다른 점.
    * 원소가 두 해시 테이블 중 어디든 저장될 수 있다.
	* 원소가 나중에 다른 위치로 이동할 수 있다.
		* 이전 설명한 해싱 방법은 재해싱을 수행하지 않는 이상 원소가 최초 삽입된 위치에서 다른 위치로 이동 못함.
		* 뻐꾸기 해싱 방법에서는 모든 원소가 두 개의 저장 가능한 위치를 가지며, 상황에 따라 이동할 수 있음. => 더 나은 성능을 얻고 재해싱 빈도를 줄이기 위해 저장 가능한 위치 개수를 증가시킬 수도 있음
* 룩업의 경우, 특정 원소가 존재하는지를 알기 위해 저장 가능한 위치 2군데만 호가인해보면 되니까 시간 복잡도는 항상 O(1)임.
* 그러나 삽입 연산은 좀 더 오래 걸릴 수 있다.
    * A라는 원소를 삽입한다고 가정
	```
    	* 삽입 함수는 먼저 첫 번째 해시 테이블에서 A를 삽입할 위치를 찾아 현재 비어 있는 지를 검사함.
		* 해당 위치가 비어 있다면 그대로 A 삽입
		* 해당 위치에 다른 원소 B가 저장되어 있다면, 해당 위치에 A를 저장하고 B를 두 번째 해시 테이블로 옮김.
		* 만약 B가 이동할 위치에 이미 다른 원소 C가 저장되어 있다면, 해당 위치에 B를 저장하고 C를 첫 번째 해시 테이블로 옮김.
		* 이런 작업을 완전히 비어 있는 셀이 나타날 때까지 재귀적으로 반복함.
    	* 이와 같은 작업에서 만약 순환이 발생한다면 무한 루프에 빠질 수 있음 => 이럴 경우 새로운 해시 함수로 재해생 수행
	```
* 열린 주소 지정 방법과 마찬가지로 뻐꾸기 해싱도 전체 해시 테이블 크기 이상의 원소를 저장할 수 없다.
* 높은 성능을 보장하려면 부하율이 0.5보다 작게끔 설정해야 함. => 전체 원소 개수가 해시 테이블 크기의 절반보다 작아야 함.
### c++ 해시 테이블
* 문자열로부터 해시 값을 생성하는 용도로 아래 함수 객체 제공함(문자열 이외에도 모든 기본 데이터 타입에 대한 해시 값을 생성한느 기능도 제공함)
	```c++
	std::hasg<std::string>(std::string)
	```
* 체이닝을 사용하는 해시 테이블
    * 아래 두 컨테이너 모두 체이닝을 사용하는 해시 테이블 형태로 구현되어 있음.
	* 해시 테이블의 각 행은 키 또는 키와 값의 쌍을 저장하는 벡터임 => **각 행을 버킷이라고 부름**
    	* 각 버킷은 하나의 리스트를 가짐.
    ```c++
    	std::unordered_set<Key> //키만 저장가능
		std::unordered_map<Key, Value> // 키와 값 함께 저장
	```
	* std::unordered_map<Key, Value>은 [] 연산자를 이용하여 주어진 키에 해당하는 값을 받을 수도 있다.
		* [] 연산자는 실제 값이 없을 때는 기본값 0을 추가한 후 반환함.
	* 위 두 컨테이너는 중복된 키를 허용하지 않는다. 만약 중복된 값을 저장하고 싶다면 아래 두 컨테이너 사용
	```
    	std::unorderd_multiset
		std::unorderd_multimap
	```
## 블룸 필터
* 해시 테이블에 비해 공간 효율이 매우 높은 방법이지만, 결정적 솔루션 대신 부정확한 결과를 얻을 수 있다.
* 블룸 필터는 거짓-부정이 없다는 것은 보장하지만, 거짓-긍정은 나올 수 있다.
    * 즉, 특정 원소가 존재한다는 긍정적인 답변을 받은 경우, 이 원소는 실제로 있을 수도 있고 없을 수도 있다.
	* 특정 원소가 존재하지 않는다는 부정적인 답변의 경우에는 확실히 없다.
* 뻐구기 해싱과 마찬가지로 블룸 필터도 여러 개의 해시 함수를 사용함. => 세 개 이상을 사용해야 한다.
* 실제 값을 저장하지는 않으며, 특정 값이 있는지 없는지를 나타내는 부울 타입 배열을 사용함.
```
	* 원소를 삽입할 경우, 모든 해시 함수 값을 계산하고 부울 타입 배열에서 이 해시 값에 대응되는 위치의 비트 값을 1로 설정
	* 룩업의 경우, 모든 해시 함수 값을 계산하고 이에 대응되는 위치의 비트 값이 1로 설정되어 있는지를 검사.
	* 만약 검사한 모든 비트가 1이면 true를 반환, 1이 아닌 비트가 하나라도 있다면 false를 반환.(이는 해당 원소가 없음을 의미)
```
* **블룸 필터는 왜 결정적이지 않을까?**
    * 특정 비트가 다수의 원소에 의해 1로 설정될 수 있기 때문에 
	* 즉, 특정 값 x와 연관된 모든 비트가 이전에 삽입된 다른 원소 값들에 의해 모두 1로 설정되어 있을 가능성이 있다는 뜻.
	* 이러한 경우 x에 대한 룩업 함수는 true를 반환할 것임. 이처럼 특정 원소가 있다고 잘못 판단하는 것을 거짓-긍정이라고 함.
	* 원소 개수가 많아질수록 거짓-긍정이 발생할 가능성은 증가함. 그러나 x와 연관된 비트 중 하나라도 1로 설정되어 있지 않다면 x가 확실하게 없다고 말할 수 있음. 그러므로 거짓-부정은 발생할 수 없다.
* 블룸 필터는 컨터이너에 실제 데이터를 저장하지 않기 때문에 다양한 타입의 데이터에 대해서도 사용할 수 있음.
* **블룸 필터를 사용하기에 적합한 상황**
    * 데이터양이 너무 ㅁ낳아서 해시 테이블조차도 사용하기가 버겁고, 거짓-양성이 있어도 괜찮은 경우
	* Gmail이나 Outlook 같은 이메일 서비스 사이트에서 새로운 이메일 주소를 만들려고 할 때, 사용자가 입력한 이메일을 이미 다른 사람이 사용하고 있는지를 검사해야 함. 데이터베이스에 수십억 개의 이메일이 있는 경우, 이러한 기본적인 검사도 매우 빈번하게 수행해야 하기 때문에 성능에 영향을 줌.
		* 사용하고 있지 않은 이메일 주소를 사용 중이라고 판단해도 큰 문제는 없다. 어차피 사용자는 다른 이메일 주소를 새로 입력할 테니. 이럴 경우 사용하면 좋다.
	* 페이스북 광고와 같은 새로운 추천 광고 선택 알고리즘 => 페이스북은 사용자가 매번 접속할 때마다 새로운 광고를 보여 줌. 이 경우 사용자가 이미 보았던 모든 광고의 ID를 블룸 필터에 저장함. 그리고 사용자가 다음 번에 접속했을 때 특정 광고의 ID를 블룸 필터에서 검색함.
		* 만약 사용자가 보지 않았던 광고를 블룸 필터가 이미 보았다고(거짓-긍저) 판단해도 단순히 해당 광고를 보여주지 않으면 그만임. 큰 문제가 되지 않는다. 이런 방식으로 매번 아주 빠르게 새로운 광고를 선택해서 보여줄 수 있다.